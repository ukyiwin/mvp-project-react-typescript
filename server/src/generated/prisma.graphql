# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Article implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublished: Boolean!
  title: String!
  body: String!
  type: Arcticletype
  author(where: UserWhereInput): User!
}

type Connect implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  to(where: UserWhereInput): User!
  from(where: UserWhereInput): User!
  accepted: Boolean!
}

type Country implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  shortName: String!
  name: String!
}

type Department implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  Country(where: CountryWhereInput): Country!
}

type Discussion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  slug: String
  content: String!
  tags: [String!]
  favourites(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  author(where: UserWhereInput): User!
  private: Boolean!
  opinions(where: OpinionsWhereInput, orderBy: OpinionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Opinions!]
}

type Faculty implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  school(where: SchoolWhereInput): School!
}

type Forum implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  slug: String
  author(where: UserWhereInput): User!
  private: Boolean!
}

type Institutions implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  type: InstitutionType!
  Country(where: CountryWhereInput): Country!
}

type Opinions implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  content: String!
  author(where: UserWhereInput): User!
  discussion(where: DiscussionWhereInput): Discussion!
}

type Post implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublished: Boolean!
  title: String!
  text: String!
}

type School implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  institution(where: InstitutionsWhereInput): Institutions!
}

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  favourites(where: DiscussionWhereInput, orderBy: DiscussionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Discussion!]
  myDiscussions(where: DiscussionWhereInput): Discussion!
  connectTo(where: ConnectWhereInput, orderBy: ConnectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connect!]
  ConectFrom(where: ConnectWhereInput, orderBy: ConnectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connect!]
  type: String!
  articles(where: ArticleWhereInput, orderBy: ArticleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Article!]
  opinions(where: OpinionsWhereInput, orderBy: OpinionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Opinions!]
}


#
# Other Types
#

type AggregateArticle {
  count: Int!
}

type AggregateConnect {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateDepartment {
  count: Int!
}

type AggregateDiscussion {
  count: Int!
}

type AggregateFaculty {
  count: Int!
}

type AggregateForum {
  count: Int!
}

type AggregateInstitutions {
  count: Int!
}

type AggregateOpinions {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateSchool {
  count: Int!
}

type AggregateUser {
  count: Int!
}

enum Arcticletype {
  External
  Internal
}

type ArticleConnection {
  pageInfo: PageInfo!
  edges: [ArticleEdge]!
  aggregate: AggregateArticle!
}

input ArticleCreateInput {
  isPublished: Boolean
  title: String!
  body: String!
  type: Arcticletype
  author: UserCreateOneWithoutArticlesInput!
}

input ArticleCreateManyWithoutAuthorInput {
  create: [ArticleCreateWithoutAuthorInput!]
  connect: [ArticleWhereUniqueInput!]
}

input ArticleCreateWithoutAuthorInput {
  isPublished: Boolean
  title: String!
  body: String!
  type: Arcticletype
}

type ArticleEdge {
  node: Article!
  cursor: String!
}

enum ArticleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  isPublished_ASC
  isPublished_DESC
  title_ASC
  title_DESC
  body_ASC
  body_DESC
  type_ASC
  type_DESC
}

type ArticlePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublished: Boolean!
  title: String!
  body: String!
  type: Arcticletype
}

type ArticleSubscriptionPayload {
  mutation: MutationType!
  node: Article
  updatedFields: [String!]
  previousValues: ArticlePreviousValues
}

input ArticleSubscriptionWhereInput {
  AND: [ArticleSubscriptionWhereInput!]
  OR: [ArticleSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ArticleWhereInput
}

input ArticleUpdateInput {
  isPublished: Boolean
  title: String
  body: String
  type: Arcticletype
  author: UserUpdateOneWithoutArticlesInput
}

input ArticleUpdateManyWithoutAuthorInput {
  create: [ArticleCreateWithoutAuthorInput!]
  connect: [ArticleWhereUniqueInput!]
  disconnect: [ArticleWhereUniqueInput!]
  delete: [ArticleWhereUniqueInput!]
  update: [ArticleUpdateWithoutAuthorInput!]
  upsert: [ArticleUpsertWithoutAuthorInput!]
}

input ArticleUpdateWithoutAuthorDataInput {
  isPublished: Boolean
  title: String
  body: String
  type: Arcticletype
}

input ArticleUpdateWithoutAuthorInput {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateWithoutAuthorDataInput!
}

input ArticleUpsertWithoutAuthorInput {
  where: ArticleWhereUniqueInput!
  update: ArticleUpdateWithoutAuthorDataInput!
  create: ArticleCreateWithoutAuthorInput!
}

input ArticleWhereInput {
  AND: [ArticleWhereInput!]
  OR: [ArticleWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  isPublished: Boolean
  isPublished_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  type: Arcticletype
  type_not: Arcticletype
  type_in: [Arcticletype!]
  type_not_in: [Arcticletype!]
  author: UserWhereInput
}

input ArticleWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type ConnectConnection {
  pageInfo: PageInfo!
  edges: [ConnectEdge]!
  aggregate: AggregateConnect!
}

input ConnectCreateInput {
  accepted: Boolean
  to: UserCreateOneWithoutConnectToInput!
  from: UserCreateOneWithoutConectFromInput!
}

input ConnectCreateManyWithoutFromInput {
  create: [ConnectCreateWithoutFromInput!]
  connect: [ConnectWhereUniqueInput!]
}

input ConnectCreateManyWithoutToInput {
  create: [ConnectCreateWithoutToInput!]
  connect: [ConnectWhereUniqueInput!]
}

input ConnectCreateWithoutFromInput {
  accepted: Boolean
  to: UserCreateOneWithoutConnectToInput!
}

input ConnectCreateWithoutToInput {
  accepted: Boolean
  from: UserCreateOneWithoutConectFromInput!
}

type ConnectEdge {
  node: Connect!
  cursor: String!
}

enum ConnectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  accepted_ASC
  accepted_DESC
}

type ConnectPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  accepted: Boolean!
}

type ConnectSubscriptionPayload {
  mutation: MutationType!
  node: Connect
  updatedFields: [String!]
  previousValues: ConnectPreviousValues
}

input ConnectSubscriptionWhereInput {
  AND: [ConnectSubscriptionWhereInput!]
  OR: [ConnectSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConnectWhereInput
}

input ConnectUpdateInput {
  accepted: Boolean
  to: UserUpdateOneWithoutConnectToInput
  from: UserUpdateOneWithoutConectFromInput
}

input ConnectUpdateManyWithoutFromInput {
  create: [ConnectCreateWithoutFromInput!]
  connect: [ConnectWhereUniqueInput!]
  disconnect: [ConnectWhereUniqueInput!]
  delete: [ConnectWhereUniqueInput!]
  update: [ConnectUpdateWithoutFromInput!]
  upsert: [ConnectUpsertWithoutFromInput!]
}

input ConnectUpdateManyWithoutToInput {
  create: [ConnectCreateWithoutToInput!]
  connect: [ConnectWhereUniqueInput!]
  disconnect: [ConnectWhereUniqueInput!]
  delete: [ConnectWhereUniqueInput!]
  update: [ConnectUpdateWithoutToInput!]
  upsert: [ConnectUpsertWithoutToInput!]
}

input ConnectUpdateWithoutFromDataInput {
  accepted: Boolean
  to: UserUpdateOneWithoutConnectToInput
}

input ConnectUpdateWithoutFromInput {
  where: ConnectWhereUniqueInput!
  data: ConnectUpdateWithoutFromDataInput!
}

input ConnectUpdateWithoutToDataInput {
  accepted: Boolean
  from: UserUpdateOneWithoutConectFromInput
}

input ConnectUpdateWithoutToInput {
  where: ConnectWhereUniqueInput!
  data: ConnectUpdateWithoutToDataInput!
}

input ConnectUpsertWithoutFromInput {
  where: ConnectWhereUniqueInput!
  update: ConnectUpdateWithoutFromDataInput!
  create: ConnectCreateWithoutFromInput!
}

input ConnectUpsertWithoutToInput {
  where: ConnectWhereUniqueInput!
  update: ConnectUpdateWithoutToDataInput!
  create: ConnectCreateWithoutToInput!
}

input ConnectWhereInput {
  AND: [ConnectWhereInput!]
  OR: [ConnectWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  accepted: Boolean
  accepted_not: Boolean
  to: UserWhereInput
  from: UserWhereInput
}

input ConnectWhereUniqueInput {
  id: ID
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  shortName: String!
  name: String!
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  shortName_ASC
  shortName_DESC
  name_ASC
  name_DESC
}

type CountryPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  shortName: String!
  name: String!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
}

input CountryUpdateDataInput {
  shortName: String
  name: String
}

input CountryUpdateInput {
  shortName: String
  name: String
}

input CountryUpdateNestedInput {
  where: CountryWhereUniqueInput!
  data: CountryUpdateDataInput!
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
  disconnect: CountryWhereUniqueInput
  delete: CountryWhereUniqueInput
  update: CountryUpdateNestedInput
  upsert: CountryUpsertNestedInput
}

input CountryUpsertNestedInput {
  where: CountryWhereUniqueInput!
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  shortName: String
  shortName_not: String
  shortName_in: [String!]
  shortName_not_in: [String!]
  shortName_lt: String
  shortName_lte: String
  shortName_gt: String
  shortName_gte: String
  shortName_contains: String
  shortName_not_contains: String
  shortName_starts_with: String
  shortName_not_starts_with: String
  shortName_ends_with: String
  shortName_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
}

input CountryWhereUniqueInput {
  id: ID
  shortName: String
  name: String
}

scalar DateTime

type DepartmentConnection {
  pageInfo: PageInfo!
  edges: [DepartmentEdge]!
  aggregate: AggregateDepartment!
}

input DepartmentCreateInput {
  name: String!
  Country: CountryCreateOneInput!
}

type DepartmentEdge {
  node: Department!
  cursor: String!
}

enum DepartmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
}

type DepartmentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type DepartmentSubscriptionPayload {
  mutation: MutationType!
  node: Department
  updatedFields: [String!]
  previousValues: DepartmentPreviousValues
}

input DepartmentSubscriptionWhereInput {
  AND: [DepartmentSubscriptionWhereInput!]
  OR: [DepartmentSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DepartmentWhereInput
}

input DepartmentUpdateInput {
  name: String
  Country: CountryUpdateOneInput
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  Country: CountryWhereInput
}

input DepartmentWhereUniqueInput {
  id: ID
}

type DiscussionConnection {
  pageInfo: PageInfo!
  edges: [DiscussionEdge]!
  aggregate: AggregateDiscussion!
}

input DiscussionCreateInput {
  title: String!
  slug: String
  content: String!
  private: Boolean
  tags: DiscussionCreatetagsInput
  favourites: UserCreateManyWithoutFavouritesInput
  author: UserCreateOneWithoutMyDiscussionsInput!
  opinions: OpinionsCreateManyWithoutDiscussionInput
}

input DiscussionCreateManyWithoutFavouritesInput {
  create: [DiscussionCreateWithoutFavouritesInput!]
  connect: [DiscussionWhereUniqueInput!]
}

input DiscussionCreateOneWithoutAuthorInput {
  create: DiscussionCreateWithoutAuthorInput
  connect: DiscussionWhereUniqueInput
}

input DiscussionCreateOneWithoutOpinionsInput {
  create: DiscussionCreateWithoutOpinionsInput
  connect: DiscussionWhereUniqueInput
}

input DiscussionCreatetagsInput {
  set: [String!]
}

input DiscussionCreateWithoutAuthorInput {
  title: String!
  slug: String
  content: String!
  private: Boolean
  tags: DiscussionCreatetagsInput
  favourites: UserCreateManyWithoutFavouritesInput
  opinions: OpinionsCreateManyWithoutDiscussionInput
}

input DiscussionCreateWithoutFavouritesInput {
  title: String!
  slug: String
  content: String!
  private: Boolean
  tags: DiscussionCreatetagsInput
  author: UserCreateOneWithoutMyDiscussionsInput!
  opinions: OpinionsCreateManyWithoutDiscussionInput
}

input DiscussionCreateWithoutOpinionsInput {
  title: String!
  slug: String
  content: String!
  private: Boolean
  tags: DiscussionCreatetagsInput
  favourites: UserCreateManyWithoutFavouritesInput
  author: UserCreateOneWithoutMyDiscussionsInput!
}

type DiscussionEdge {
  node: Discussion!
  cursor: String!
}

enum DiscussionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
  content_ASC
  content_DESC
  private_ASC
  private_DESC
}

type DiscussionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  slug: String
  content: String!
  tags: [String!]
  private: Boolean!
}

type DiscussionSubscriptionPayload {
  mutation: MutationType!
  node: Discussion
  updatedFields: [String!]
  previousValues: DiscussionPreviousValues
}

input DiscussionSubscriptionWhereInput {
  AND: [DiscussionSubscriptionWhereInput!]
  OR: [DiscussionSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiscussionWhereInput
}

input DiscussionUpdateInput {
  title: String
  slug: String
  content: String
  private: Boolean
  tags: DiscussionUpdatetagsInput
  favourites: UserUpdateManyWithoutFavouritesInput
  author: UserUpdateOneWithoutMyDiscussionsInput
  opinions: OpinionsUpdateManyWithoutDiscussionInput
}

input DiscussionUpdateManyWithoutFavouritesInput {
  create: [DiscussionCreateWithoutFavouritesInput!]
  connect: [DiscussionWhereUniqueInput!]
  disconnect: [DiscussionWhereUniqueInput!]
  delete: [DiscussionWhereUniqueInput!]
  update: [DiscussionUpdateWithoutFavouritesInput!]
  upsert: [DiscussionUpsertWithoutFavouritesInput!]
}

input DiscussionUpdateOneWithoutAuthorInput {
  create: DiscussionCreateWithoutAuthorInput
  connect: DiscussionWhereUniqueInput
  disconnect: DiscussionWhereUniqueInput
  delete: DiscussionWhereUniqueInput
  update: DiscussionUpdateWithoutAuthorInput
  upsert: DiscussionUpsertWithoutAuthorInput
}

input DiscussionUpdateOneWithoutOpinionsInput {
  create: DiscussionCreateWithoutOpinionsInput
  connect: DiscussionWhereUniqueInput
  disconnect: DiscussionWhereUniqueInput
  delete: DiscussionWhereUniqueInput
  update: DiscussionUpdateWithoutOpinionsInput
  upsert: DiscussionUpsertWithoutOpinionsInput
}

input DiscussionUpdatetagsInput {
  set: [String!]
}

input DiscussionUpdateWithoutAuthorDataInput {
  title: String
  slug: String
  content: String
  private: Boolean
  tags: DiscussionUpdatetagsInput
  favourites: UserUpdateManyWithoutFavouritesInput
  opinions: OpinionsUpdateManyWithoutDiscussionInput
}

input DiscussionUpdateWithoutAuthorInput {
  where: DiscussionWhereUniqueInput!
  data: DiscussionUpdateWithoutAuthorDataInput!
}

input DiscussionUpdateWithoutFavouritesDataInput {
  title: String
  slug: String
  content: String
  private: Boolean
  tags: DiscussionUpdatetagsInput
  author: UserUpdateOneWithoutMyDiscussionsInput
  opinions: OpinionsUpdateManyWithoutDiscussionInput
}

input DiscussionUpdateWithoutFavouritesInput {
  where: DiscussionWhereUniqueInput!
  data: DiscussionUpdateWithoutFavouritesDataInput!
}

input DiscussionUpdateWithoutOpinionsDataInput {
  title: String
  slug: String
  content: String
  private: Boolean
  tags: DiscussionUpdatetagsInput
  favourites: UserUpdateManyWithoutFavouritesInput
  author: UserUpdateOneWithoutMyDiscussionsInput
}

input DiscussionUpdateWithoutOpinionsInput {
  where: DiscussionWhereUniqueInput!
  data: DiscussionUpdateWithoutOpinionsDataInput!
}

input DiscussionUpsertWithoutAuthorInput {
  where: DiscussionWhereUniqueInput!
  update: DiscussionUpdateWithoutAuthorDataInput!
  create: DiscussionCreateWithoutAuthorInput!
}

input DiscussionUpsertWithoutFavouritesInput {
  where: DiscussionWhereUniqueInput!
  update: DiscussionUpdateWithoutFavouritesDataInput!
  create: DiscussionCreateWithoutFavouritesInput!
}

input DiscussionUpsertWithoutOpinionsInput {
  where: DiscussionWhereUniqueInput!
  update: DiscussionUpdateWithoutOpinionsDataInput!
  create: DiscussionCreateWithoutOpinionsInput!
}

input DiscussionWhereInput {
  AND: [DiscussionWhereInput!]
  OR: [DiscussionWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  private: Boolean
  private_not: Boolean
  favourites_every: UserWhereInput
  favourites_some: UserWhereInput
  favourites_none: UserWhereInput
  author: UserWhereInput
  opinions_every: OpinionsWhereInput
  opinions_some: OpinionsWhereInput
  opinions_none: OpinionsWhereInput
}

input DiscussionWhereUniqueInput {
  id: ID
}

type FacultyConnection {
  pageInfo: PageInfo!
  edges: [FacultyEdge]!
  aggregate: AggregateFaculty!
}

input FacultyCreateInput {
  name: String!
  school: SchoolCreateOneInput!
}

type FacultyEdge {
  node: Faculty!
  cursor: String!
}

enum FacultyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
}

type FacultyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type FacultySubscriptionPayload {
  mutation: MutationType!
  node: Faculty
  updatedFields: [String!]
  previousValues: FacultyPreviousValues
}

input FacultySubscriptionWhereInput {
  AND: [FacultySubscriptionWhereInput!]
  OR: [FacultySubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FacultyWhereInput
}

input FacultyUpdateInput {
  name: String
  school: SchoolUpdateOneInput
}

input FacultyWhereInput {
  AND: [FacultyWhereInput!]
  OR: [FacultyWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  school: SchoolWhereInput
}

input FacultyWhereUniqueInput {
  id: ID
}

type ForumConnection {
  pageInfo: PageInfo!
  edges: [ForumEdge]!
  aggregate: AggregateForum!
}

input ForumCreateInput {
  title: String!
  slug: String
  private: Boolean
  author: UserCreateOneInput!
}

type ForumEdge {
  node: Forum!
  cursor: String!
}

enum ForumOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
  private_ASC
  private_DESC
}

type ForumPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  slug: String
  private: Boolean!
}

type ForumSubscriptionPayload {
  mutation: MutationType!
  node: Forum
  updatedFields: [String!]
  previousValues: ForumPreviousValues
}

input ForumSubscriptionWhereInput {
  AND: [ForumSubscriptionWhereInput!]
  OR: [ForumSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ForumWhereInput
}

input ForumUpdateInput {
  title: String
  slug: String
  private: Boolean
  author: UserUpdateOneInput
}

input ForumWhereInput {
  AND: [ForumWhereInput!]
  OR: [ForumWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  private: Boolean
  private_not: Boolean
  author: UserWhereInput
}

input ForumWhereUniqueInput {
  id: ID
}

type InstitutionsConnection {
  pageInfo: PageInfo!
  edges: [InstitutionsEdge]!
  aggregate: AggregateInstitutions!
}

input InstitutionsCreateInput {
  title: String!
  type: InstitutionType!
  Country: CountryCreateOneInput!
}

input InstitutionsCreateOneInput {
  create: InstitutionsCreateInput
  connect: InstitutionsWhereUniqueInput
}

type InstitutionsEdge {
  node: Institutions!
  cursor: String!
}

enum InstitutionsOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  type_ASC
  type_DESC
}

type InstitutionsPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  type: InstitutionType!
}

type InstitutionsSubscriptionPayload {
  mutation: MutationType!
  node: Institutions
  updatedFields: [String!]
  previousValues: InstitutionsPreviousValues
}

input InstitutionsSubscriptionWhereInput {
  AND: [InstitutionsSubscriptionWhereInput!]
  OR: [InstitutionsSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InstitutionsWhereInput
}

input InstitutionsUpdateDataInput {
  title: String
  type: InstitutionType
  Country: CountryUpdateOneInput
}

input InstitutionsUpdateInput {
  title: String
  type: InstitutionType
  Country: CountryUpdateOneInput
}

input InstitutionsUpdateNestedInput {
  where: InstitutionsWhereUniqueInput!
  data: InstitutionsUpdateDataInput!
}

input InstitutionsUpdateOneInput {
  create: InstitutionsCreateInput
  connect: InstitutionsWhereUniqueInput
  disconnect: InstitutionsWhereUniqueInput
  delete: InstitutionsWhereUniqueInput
  update: InstitutionsUpdateNestedInput
  upsert: InstitutionsUpsertNestedInput
}

input InstitutionsUpsertNestedInput {
  where: InstitutionsWhereUniqueInput!
  update: InstitutionsUpdateDataInput!
  create: InstitutionsCreateInput!
}

input InstitutionsWhereInput {
  AND: [InstitutionsWhereInput!]
  OR: [InstitutionsWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  type: InstitutionType
  type_not: InstitutionType
  type_in: [InstitutionType!]
  type_not_in: [InstitutionType!]
  Country: CountryWhereInput
}

input InstitutionsWhereUniqueInput {
  id: ID
}

enum InstitutionType {
  University
  College
}

scalar Long

type Mutation {
  createPost(data: PostCreateInput!): Post!
  createArticle(data: ArticleCreateInput!): Article!
  createCountry(data: CountryCreateInput!): Country!
  createInstitutions(data: InstitutionsCreateInput!): Institutions!
  createSchool(data: SchoolCreateInput!): School!
  createFaculty(data: FacultyCreateInput!): Faculty!
  createDepartment(data: DepartmentCreateInput!): Department!
  createUser(data: UserCreateInput!): User!
  createConnect(data: ConnectCreateInput!): Connect!
  createForum(data: ForumCreateInput!): Forum!
  createDiscussion(data: DiscussionCreateInput!): Discussion!
  createOpinions(data: OpinionsCreateInput!): Opinions!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateArticle(data: ArticleUpdateInput!, where: ArticleWhereUniqueInput!): Article
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateInstitutions(data: InstitutionsUpdateInput!, where: InstitutionsWhereUniqueInput!): Institutions
  updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
  updateFaculty(data: FacultyUpdateInput!, where: FacultyWhereUniqueInput!): Faculty
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateConnect(data: ConnectUpdateInput!, where: ConnectWhereUniqueInput!): Connect
  updateForum(data: ForumUpdateInput!, where: ForumWhereUniqueInput!): Forum
  updateDiscussion(data: DiscussionUpdateInput!, where: DiscussionWhereUniqueInput!): Discussion
  updateOpinions(data: OpinionsUpdateInput!, where: OpinionsWhereUniqueInput!): Opinions
  deletePost(where: PostWhereUniqueInput!): Post
  deleteArticle(where: ArticleWhereUniqueInput!): Article
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteInstitutions(where: InstitutionsWhereUniqueInput!): Institutions
  deleteSchool(where: SchoolWhereUniqueInput!): School
  deleteFaculty(where: FacultyWhereUniqueInput!): Faculty
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteUser(where: UserWhereUniqueInput!): User
  deleteConnect(where: ConnectWhereUniqueInput!): Connect
  deleteForum(where: ForumWhereUniqueInput!): Forum
  deleteDiscussion(where: DiscussionWhereUniqueInput!): Discussion
  deleteOpinions(where: OpinionsWhereUniqueInput!): Opinions
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  upsertArticle(where: ArticleWhereUniqueInput!, create: ArticleCreateInput!, update: ArticleUpdateInput!): Article!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  upsertInstitutions(where: InstitutionsWhereUniqueInput!, create: InstitutionsCreateInput!, update: InstitutionsUpdateInput!): Institutions!
  upsertSchool(where: SchoolWhereUniqueInput!, create: SchoolCreateInput!, update: SchoolUpdateInput!): School!
  upsertFaculty(where: FacultyWhereUniqueInput!, create: FacultyCreateInput!, update: FacultyUpdateInput!): Faculty!
  upsertDepartment(where: DepartmentWhereUniqueInput!, create: DepartmentCreateInput!, update: DepartmentUpdateInput!): Department!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertConnect(where: ConnectWhereUniqueInput!, create: ConnectCreateInput!, update: ConnectUpdateInput!): Connect!
  upsertForum(where: ForumWhereUniqueInput!, create: ForumCreateInput!, update: ForumUpdateInput!): Forum!
  upsertDiscussion(where: DiscussionWhereUniqueInput!, create: DiscussionCreateInput!, update: DiscussionUpdateInput!): Discussion!
  upsertOpinions(where: OpinionsWhereUniqueInput!, create: OpinionsCreateInput!, update: OpinionsUpdateInput!): Opinions!
  updateManyPosts(data: PostUpdateInput!, where: PostWhereInput!): BatchPayload!
  updateManyArticles(data: ArticleUpdateInput!, where: ArticleWhereInput!): BatchPayload!
  updateManyCountries(data: CountryUpdateInput!, where: CountryWhereInput!): BatchPayload!
  updateManyInstitutionses(data: InstitutionsUpdateInput!, where: InstitutionsWhereInput!): BatchPayload!
  updateManySchools(data: SchoolUpdateInput!, where: SchoolWhereInput!): BatchPayload!
  updateManyFaculties(data: FacultyUpdateInput!, where: FacultyWhereInput!): BatchPayload!
  updateManyDepartments(data: DepartmentUpdateInput!, where: DepartmentWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyConnects(data: ConnectUpdateInput!, where: ConnectWhereInput!): BatchPayload!
  updateManyForums(data: ForumUpdateInput!, where: ForumWhereInput!): BatchPayload!
  updateManyDiscussions(data: DiscussionUpdateInput!, where: DiscussionWhereInput!): BatchPayload!
  updateManyOpinionses(data: OpinionsUpdateInput!, where: OpinionsWhereInput!): BatchPayload!
  deleteManyPosts(where: PostWhereInput!): BatchPayload!
  deleteManyArticles(where: ArticleWhereInput!): BatchPayload!
  deleteManyCountries(where: CountryWhereInput!): BatchPayload!
  deleteManyInstitutionses(where: InstitutionsWhereInput!): BatchPayload!
  deleteManySchools(where: SchoolWhereInput!): BatchPayload!
  deleteManyFaculties(where: FacultyWhereInput!): BatchPayload!
  deleteManyDepartments(where: DepartmentWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyConnects(where: ConnectWhereInput!): BatchPayload!
  deleteManyForums(where: ForumWhereInput!): BatchPayload!
  deleteManyDiscussions(where: DiscussionWhereInput!): BatchPayload!
  deleteManyOpinionses(where: OpinionsWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type OpinionsConnection {
  pageInfo: PageInfo!
  edges: [OpinionsEdge]!
  aggregate: AggregateOpinions!
}

input OpinionsCreateInput {
  content: String!
  author: UserCreateOneWithoutOpinionsInput!
  discussion: DiscussionCreateOneWithoutOpinionsInput!
}

input OpinionsCreateManyWithoutAuthorInput {
  create: [OpinionsCreateWithoutAuthorInput!]
  connect: [OpinionsWhereUniqueInput!]
}

input OpinionsCreateManyWithoutDiscussionInput {
  create: [OpinionsCreateWithoutDiscussionInput!]
  connect: [OpinionsWhereUniqueInput!]
}

input OpinionsCreateWithoutAuthorInput {
  content: String!
  discussion: DiscussionCreateOneWithoutOpinionsInput!
}

input OpinionsCreateWithoutDiscussionInput {
  content: String!
  author: UserCreateOneWithoutOpinionsInput!
}

type OpinionsEdge {
  node: Opinions!
  cursor: String!
}

enum OpinionsOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  content_ASC
  content_DESC
}

type OpinionsPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  content: String!
}

type OpinionsSubscriptionPayload {
  mutation: MutationType!
  node: Opinions
  updatedFields: [String!]
  previousValues: OpinionsPreviousValues
}

input OpinionsSubscriptionWhereInput {
  AND: [OpinionsSubscriptionWhereInput!]
  OR: [OpinionsSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OpinionsWhereInput
}

input OpinionsUpdateInput {
  content: String
  author: UserUpdateOneWithoutOpinionsInput
  discussion: DiscussionUpdateOneWithoutOpinionsInput
}

input OpinionsUpdateManyWithoutAuthorInput {
  create: [OpinionsCreateWithoutAuthorInput!]
  connect: [OpinionsWhereUniqueInput!]
  disconnect: [OpinionsWhereUniqueInput!]
  delete: [OpinionsWhereUniqueInput!]
  update: [OpinionsUpdateWithoutAuthorInput!]
  upsert: [OpinionsUpsertWithoutAuthorInput!]
}

input OpinionsUpdateManyWithoutDiscussionInput {
  create: [OpinionsCreateWithoutDiscussionInput!]
  connect: [OpinionsWhereUniqueInput!]
  disconnect: [OpinionsWhereUniqueInput!]
  delete: [OpinionsWhereUniqueInput!]
  update: [OpinionsUpdateWithoutDiscussionInput!]
  upsert: [OpinionsUpsertWithoutDiscussionInput!]
}

input OpinionsUpdateWithoutAuthorDataInput {
  content: String
  discussion: DiscussionUpdateOneWithoutOpinionsInput
}

input OpinionsUpdateWithoutAuthorInput {
  where: OpinionsWhereUniqueInput!
  data: OpinionsUpdateWithoutAuthorDataInput!
}

input OpinionsUpdateWithoutDiscussionDataInput {
  content: String
  author: UserUpdateOneWithoutOpinionsInput
}

input OpinionsUpdateWithoutDiscussionInput {
  where: OpinionsWhereUniqueInput!
  data: OpinionsUpdateWithoutDiscussionDataInput!
}

input OpinionsUpsertWithoutAuthorInput {
  where: OpinionsWhereUniqueInput!
  update: OpinionsUpdateWithoutAuthorDataInput!
  create: OpinionsCreateWithoutAuthorInput!
}

input OpinionsUpsertWithoutDiscussionInput {
  where: OpinionsWhereUniqueInput!
  update: OpinionsUpdateWithoutDiscussionDataInput!
  create: OpinionsCreateWithoutDiscussionInput!
}

input OpinionsWhereInput {
  AND: [OpinionsWhereInput!]
  OR: [OpinionsWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  author: UserWhereInput
  discussion: DiscussionWhereInput
}

input OpinionsWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  isPublished: Boolean
  title: String!
  text: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  isPublished_ASC
  isPublished_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
}

type PostPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublished: Boolean!
  title: String!
  text: String!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
}

input PostUpdateInput {
  isPublished: Boolean
  title: String
  text: String
}

input PostWhereInput {
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  isPublished: Boolean
  isPublished_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  articles(where: ArticleWhereInput, orderBy: ArticleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Article]!
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  institutionses(where: InstitutionsWhereInput, orderBy: InstitutionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Institutions]!
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School]!
  faculties(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Faculty]!
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  connects(where: ConnectWhereInput, orderBy: ConnectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connect]!
  forums(where: ForumWhereInput, orderBy: ForumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Forum]!
  discussions(where: DiscussionWhereInput, orderBy: DiscussionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Discussion]!
  opinionses(where: OpinionsWhereInput, orderBy: OpinionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Opinions]!
  post(where: PostWhereUniqueInput!): Post
  article(where: ArticleWhereUniqueInput!): Article
  country(where: CountryWhereUniqueInput!): Country
  institutions(where: InstitutionsWhereUniqueInput!): Institutions
  school(where: SchoolWhereUniqueInput!): School
  faculty(where: FacultyWhereUniqueInput!): Faculty
  department(where: DepartmentWhereUniqueInput!): Department
  user(where: UserWhereUniqueInput!): User
  connect(where: ConnectWhereUniqueInput!): Connect
  forum(where: ForumWhereUniqueInput!): Forum
  discussion(where: DiscussionWhereUniqueInput!): Discussion
  opinions(where: OpinionsWhereUniqueInput!): Opinions
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  articlesConnection(where: ArticleWhereInput, orderBy: ArticleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArticleConnection!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  institutionsesConnection(where: InstitutionsWhereInput, orderBy: InstitutionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InstitutionsConnection!
  schoolsConnection(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolConnection!
  facultiesConnection(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacultyConnection!
  departmentsConnection(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DepartmentConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  connectsConnection(where: ConnectWhereInput, orderBy: ConnectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConnectConnection!
  forumsConnection(where: ForumWhereInput, orderBy: ForumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ForumConnection!
  discussionsConnection(where: DiscussionWhereInput, orderBy: DiscussionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiscussionConnection!
  opinionsesConnection(where: OpinionsWhereInput, orderBy: OpinionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OpinionsConnection!
  node(id: ID!): Node
}

type SchoolConnection {
  pageInfo: PageInfo!
  edges: [SchoolEdge]!
  aggregate: AggregateSchool!
}

input SchoolCreateInput {
  title: String!
  institution: InstitutionsCreateOneInput!
}

input SchoolCreateOneInput {
  create: SchoolCreateInput
  connect: SchoolWhereUniqueInput
}

type SchoolEdge {
  node: School!
  cursor: String!
}

enum SchoolOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
}

type SchoolPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
}

type SchoolSubscriptionPayload {
  mutation: MutationType!
  node: School
  updatedFields: [String!]
  previousValues: SchoolPreviousValues
}

input SchoolSubscriptionWhereInput {
  AND: [SchoolSubscriptionWhereInput!]
  OR: [SchoolSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SchoolWhereInput
}

input SchoolUpdateDataInput {
  title: String
  institution: InstitutionsUpdateOneInput
}

input SchoolUpdateInput {
  title: String
  institution: InstitutionsUpdateOneInput
}

input SchoolUpdateNestedInput {
  where: SchoolWhereUniqueInput!
  data: SchoolUpdateDataInput!
}

input SchoolUpdateOneInput {
  create: SchoolCreateInput
  connect: SchoolWhereUniqueInput
  disconnect: SchoolWhereUniqueInput
  delete: SchoolWhereUniqueInput
  update: SchoolUpdateNestedInput
  upsert: SchoolUpsertNestedInput
}

input SchoolUpsertNestedInput {
  where: SchoolWhereUniqueInput!
  update: SchoolUpdateDataInput!
  create: SchoolCreateInput!
}

input SchoolWhereInput {
  AND: [SchoolWhereInput!]
  OR: [SchoolWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  institution: InstitutionsWhereInput
}

input SchoolWhereUniqueInput {
  id: ID
}

type Subscription {
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  article(where: ArticleSubscriptionWhereInput): ArticleSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  institutions(where: InstitutionsSubscriptionWhereInput): InstitutionsSubscriptionPayload
  school(where: SchoolSubscriptionWhereInput): SchoolSubscriptionPayload
  faculty(where: FacultySubscriptionWhereInput): FacultySubscriptionPayload
  department(where: DepartmentSubscriptionWhereInput): DepartmentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  connect(where: ConnectSubscriptionWhereInput): ConnectSubscriptionPayload
  forum(where: ForumSubscriptionWhereInput): ForumSubscriptionPayload
  discussion(where: DiscussionSubscriptionWhereInput): DiscussionSubscriptionPayload
  opinions(where: OpinionsSubscriptionWhereInput): OpinionsSubscriptionPayload
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  connectTo: ConnectCreateManyWithoutToInput
  ConectFrom: ConnectCreateManyWithoutFromInput
  articles: ArticleCreateManyWithoutAuthorInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateManyWithoutFavouritesInput {
  create: [UserCreateWithoutFavouritesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutArticlesInput {
  create: UserCreateWithoutArticlesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutConectFromInput {
  create: UserCreateWithoutConectFromInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutConnectToInput {
  create: UserCreateWithoutConnectToInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMyDiscussionsInput {
  create: UserCreateWithoutMyDiscussionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOpinionsInput {
  create: UserCreateWithoutOpinionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutArticlesInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  connectTo: ConnectCreateManyWithoutToInput
  ConectFrom: ConnectCreateManyWithoutFromInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateWithoutConectFromInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  connectTo: ConnectCreateManyWithoutToInput
  articles: ArticleCreateManyWithoutAuthorInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateWithoutConnectToInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  ConectFrom: ConnectCreateManyWithoutFromInput
  articles: ArticleCreateManyWithoutAuthorInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateWithoutFavouritesInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  connectTo: ConnectCreateManyWithoutToInput
  ConectFrom: ConnectCreateManyWithoutFromInput
  articles: ArticleCreateManyWithoutAuthorInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateWithoutMyDiscussionsInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  connectTo: ConnectCreateManyWithoutToInput
  ConectFrom: ConnectCreateManyWithoutFromInput
  articles: ArticleCreateManyWithoutAuthorInput
  opinions: OpinionsCreateManyWithoutAuthorInput
}

input UserCreateWithoutOpinionsInput {
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
  favourites: DiscussionCreateManyWithoutFavouritesInput
  myDiscussions: DiscussionCreateOneWithoutAuthorInput!
  connectTo: ConnectCreateManyWithoutToInput
  ConectFrom: ConnectCreateManyWithoutFromInput
  articles: ArticleCreateManyWithoutAuthorInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  gender_ASC
  gender_DESC
  type_ASC
  type_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  username: String
  password: String!
  firstname: String!
  lastname: String!
  gender: String!
  type: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateManyWithoutFavouritesInput {
  create: [UserCreateWithoutFavouritesInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithoutFavouritesInput!]
  upsert: [UserUpsertWithoutFavouritesInput!]
}

input UserUpdateNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateNestedInput
  upsert: UserUpsertNestedInput
}

input UserUpdateOneWithoutArticlesInput {
  create: UserCreateWithoutArticlesInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutArticlesInput
  upsert: UserUpsertWithoutArticlesInput
}

input UserUpdateOneWithoutConectFromInput {
  create: UserCreateWithoutConectFromInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutConectFromInput
  upsert: UserUpsertWithoutConectFromInput
}

input UserUpdateOneWithoutConnectToInput {
  create: UserCreateWithoutConnectToInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutConnectToInput
  upsert: UserUpsertWithoutConnectToInput
}

input UserUpdateOneWithoutMyDiscussionsInput {
  create: UserCreateWithoutMyDiscussionsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutMyDiscussionsInput
  upsert: UserUpsertWithoutMyDiscussionsInput
}

input UserUpdateOneWithoutOpinionsInput {
  create: UserCreateWithoutOpinionsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutOpinionsInput
  upsert: UserUpsertWithoutOpinionsInput
}

input UserUpdateWithoutArticlesDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutArticlesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutArticlesDataInput!
}

input UserUpdateWithoutConectFromDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutConectFromInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutConectFromDataInput!
}

input UserUpdateWithoutConnectToDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutConnectToInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutConnectToDataInput!
}

input UserUpdateWithoutFavouritesDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutFavouritesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFavouritesDataInput!
}

input UserUpdateWithoutMyDiscussionsDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
  opinions: OpinionsUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutMyDiscussionsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutMyDiscussionsDataInput!
}

input UserUpdateWithoutOpinionsDataInput {
  email: String
  username: String
  password: String
  firstname: String
  lastname: String
  gender: String
  type: String
  favourites: DiscussionUpdateManyWithoutFavouritesInput
  myDiscussions: DiscussionUpdateOneWithoutAuthorInput
  connectTo: ConnectUpdateManyWithoutToInput
  ConectFrom: ConnectUpdateManyWithoutFromInput
  articles: ArticleUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutOpinionsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutOpinionsDataInput!
}

input UserUpsertNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutArticlesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutArticlesDataInput!
  create: UserCreateWithoutArticlesInput!
}

input UserUpsertWithoutConectFromInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutConectFromDataInput!
  create: UserCreateWithoutConectFromInput!
}

input UserUpsertWithoutConnectToInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutConnectToDataInput!
  create: UserCreateWithoutConnectToInput!
}

input UserUpsertWithoutFavouritesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFavouritesDataInput!
  create: UserCreateWithoutFavouritesInput!
}

input UserUpsertWithoutMyDiscussionsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutMyDiscussionsDataInput!
  create: UserCreateWithoutMyDiscussionsInput!
}

input UserUpsertWithoutOpinionsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutOpinionsDataInput!
  create: UserCreateWithoutOpinionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  favourites_every: DiscussionWhereInput
  favourites_some: DiscussionWhereInput
  favourites_none: DiscussionWhereInput
  myDiscussions: DiscussionWhereInput
  connectTo_every: ConnectWhereInput
  connectTo_some: ConnectWhereInput
  connectTo_none: ConnectWhereInput
  ConectFrom_every: ConnectWhereInput
  ConectFrom_some: ConnectWhereInput
  ConectFrom_none: ConnectWhereInput
  articles_every: ArticleWhereInput
  articles_some: ArticleWhereInput
  articles_none: ArticleWhereInput
  opinions_every: OpinionsWhereInput
  opinions_some: OpinionsWhereInput
  opinions_none: OpinionsWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
  username: String
}
